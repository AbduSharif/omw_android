diff --git a/CHANGELOG.md b/CHANGELOG.md
index 419727c87dedeccff21c5fd36e5e5864d329b84f..33a20a0a9c7f9be1a68dd4392fa4a82f21589818 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -123,6 +123,7 @@
     Feature #6288: Preserve the "blocked" record flag for referenceable objects.
     Feature #6380: Commas are treated as whitespace in vanilla
     Feature #6419: Topics shouldn't be greyed out if they can produce another topic reference
+    Feature #6541: Gloss-mapping
     Task #6201: Remove the "Note: No relevant classes found. No output generated" warnings
     Task #6264: Remove the old classes in animation.cpp
 
diff --git a/components/nifosg/nifloader.cpp b/components/nifosg/nifloader.cpp
index 43af68fc9004a23c44d2e7e795c9800b0e06ca85..0b143ed643ec39f37ae9053c9688f166c4fe9aae 100644
--- a/components/nifosg/nifloader.cpp
+++ b/components/nifosg/nifloader.cpp
@@ -1131,18 +1131,18 @@ namespace NifOsg
 
             const auto& uvlist = data->uvlist;
             int textureStage = 0;
-            for (const unsigned int uvSet : boundTextures)
+            for (std::vector<unsigned int>::const_iterator it = boundTextures.begin(); it != boundTextures.end(); ++it, ++textureStage)
             {
+                unsigned int uvSet = *it;
                 if (uvSet >= uvlist.size())
                 {
                     Log(Debug::Verbose) << "Out of bounds UV set " << uvSet << " on shape \"" << name << "\" in " << mFilename;
-                    if (!uvlist.empty())
-                        geometry->setTexCoordArray(textureStage, new osg::Vec2Array(uvlist[0].size(), uvlist[0].data()), osg::Array::BIND_PER_VERTEX);
-                    continue;
+                    if (uvlist.empty())
+                        continue;
+                    uvSet = 0;
                 }
 
                 geometry->setTexCoordArray(textureStage, new osg::Vec2Array(uvlist[uvSet].size(), uvlist[uvSet].data()), osg::Array::BIND_PER_VERTEX);
-                textureStage++;
             }
         }
 
@@ -1495,14 +1495,8 @@ namespace NifOsg
                         case Nif::NiTexturingProperty::BumpTexture:
                         case Nif::NiTexturingProperty::DetailTexture:
                         case Nif::NiTexturingProperty::DecalTexture:
-                            break;
                         case Nif::NiTexturingProperty::GlossTexture:
-                        {
-                            // Not used by the vanilla engine. MCP (Morrowind Code Patch) adds an option to use Gloss maps:
-                            // "- Gloss map fix. Morrowind removed gloss map entries from model files after loading them. This stops Morrowind from removing them."
-                            // Log(Debug::Info) << "NiTexturingProperty::GlossTexture in " << mFilename << " not currently used.";
-                            continue;
-                        }
+                            break;
                         default:
                         {
                             Log(Debug::Info) << "Unhandled texture stage " << i << " on shape \"" << nodeName << "\" in " << mFilename;
@@ -1594,6 +1588,12 @@ namespace NifOsg
                         stateset->addUniform(new osg::Uniform("bumpMapMatrix", bumpMapMatrix));
                         stateset->addUniform(new osg::Uniform("envMapLumaBias", texprop->envMapLumaBias));
                     }
+                    else if (i == Nif::NiTexturingProperty::GlossTexture)
+                    {
+                        // A gloss map is an environment map mask.
+                        // Gloss maps are only implemented in the object shaders as well.
+                        stateset->setTextureMode(texUnit, GL_TEXTURE_2D, osg::StateAttribute::OFF);
+                    }
                     else if (i == Nif::NiTexturingProperty::DecalTexture)
                     {
                         // This is only an inaccurate imitation of the original implementation,
@@ -1637,6 +1637,9 @@ namespace NifOsg
                     case Nif::NiTexturingProperty::DecalTexture:
                         texture2d->setName("decalMap");
                         break;
+                    case Nif::NiTexturingProperty::GlossTexture:
+                        texture2d->setName("glossMap");
+                        break;
                     default:
                         break;
                     }
diff --git a/components/shader/shadervisitor.cpp b/components/shader/shadervisitor.cpp
index 107665369c21666374806b1e736664505696d4c1..d8bbeeadc2997a805e3fc61158ede1fe82331fd9 100644
--- a/components/shader/shadervisitor.cpp
+++ b/components/shader/shadervisitor.cpp
@@ -244,7 +244,7 @@ namespace Shader
         addedState->setName("addedState");
     }
 
-    const char* defaultTextures[] = { "diffuseMap", "normalMap", "emissiveMap", "darkMap", "detailMap", "envMap", "specularMap", "decalMap", "bumpMap" };
+    const char* defaultTextures[] = { "diffuseMap", "normalMap", "emissiveMap", "darkMap", "detailMap", "envMap", "specularMap", "decalMap", "bumpMap", "glossMap" };
     bool isTextureNameRecognized(const std::string& name)
     {
         for (unsigned int i=0; i<sizeof(defaultTextures)/sizeof(defaultTextures[0]); ++i)
@@ -325,6 +325,14 @@ namespace Shader
                             {
                                 mRequirements.back().mShaderRequired = true;
                             }
+                            else if (texName == "glossMap")
+                            {
+                                mRequirements.back().mShaderRequired = true;
+                                if (!writableStateSet)
+                                    writableStateSet = getWritableStateSet(node);
+                                // As well as gloss maps
+                                writableStateSet->setTextureMode(unit, GL_TEXTURE_2D, osg::StateAttribute::ON);
+                            }
                         }
                         else
                             Log(Debug::Error) << "ShaderVisitor encountered unknown texture " << texture;
diff --git a/files/shaders/objects_fragment.glsl b/files/shaders/objects_fragment.glsl
index 9b60e7c6a49b2c82c6b4b3287a37344cad053cb2..85950c7468ce1a873d0b9dec3fb67bd46b68b879 100644
--- a/files/shaders/objects_fragment.glsl
+++ b/files/shaders/objects_fragment.glsl
@@ -58,6 +58,11 @@ uniform vec2 envMapLumaBias;
 uniform mat2 bumpMapMatrix;
 #endif
 
+#if @glossMap
+uniform sampler2D glossMap;
+varying vec2 glossMapUV;
+#endif
+
 uniform bool simpleWater;
 
 varying float euclideanDepth;
@@ -168,8 +173,14 @@ void main()
     envLuma = clamp(bumpTex.b * envMapLumaBias.x + envMapLumaBias.y, 0.0, 1.0);
 #endif
 
+    vec3 envEffect = texture2D(envMap, envTexCoordGen).xyz * envMapColor.xyz * envLuma;
+
+#if @glossMap
+    envEffect *= texture2D(glossMap, glossMapUV).xyz;
+#endif
+
 #if @preLightEnv
-    gl_FragData[0].xyz += texture2D(envMap, envTexCoordGen).xyz * envMapColor.xyz * envLuma;
+    gl_FragData[0].xyz += envEffect;
 #endif
 
 #endif
@@ -189,7 +200,7 @@ void main()
     gl_FragData[0].xyz *= lighting;
 
 #if @envMap && !@preLightEnv
-    gl_FragData[0].xyz += texture2D(envMap, envTexCoordGen).xyz * envMapColor.xyz * envLuma;
+    gl_FragData[0].xyz += envEffect;
 #endif
 
 #if @emissiveMap
diff --git a/files/shaders/objects_vertex.glsl b/files/shaders/objects_vertex.glsl
index 969fe5903e5a3fa0f6923ee1f08f8330d7982e8c..77c7fef39164f5c732a69fd13cd501f63f9bf097 100644
--- a/files/shaders/objects_vertex.glsl
+++ b/files/shaders/objects_vertex.glsl
@@ -47,6 +47,10 @@ varying vec2 bumpMapUV;
 varying vec2 specularMapUV;
 #endif
 
+#if @glossMap
+varying vec2 glossMapUV;
+#endif
+
 varying float euclideanDepth;
 varying float linearDepth;
 
@@ -120,6 +124,10 @@ void main(void)
     specularMapUV = (gl_TextureMatrix[@specularMapUV] * gl_MultiTexCoord@specularMapUV).xy;
 #endif
 
+#if @glossMap
+    glossMapUV = (gl_TextureMatrix[@glossMapUV] * gl_MultiTexCoord@glossMapUV).xy;
+#endif
+
     passColor = gl_Color;
     passViewPos = viewPos.xyz;
     passNormal = gl_Normal.xyz;
