diff --git a/components/nifosg/nifloader.cpp b/components/nifosg/nifloader.cpp
index 43af68fc9004a23c44d2e7e795c9800b0e06ca85..0b143ed643ec39f37ae9053c9688f166c4fe9aae 100644
--- a/components/nifosg/nifloader.cpp
+++ b/components/nifosg/nifloader.cpp
@@ -1131,18 +1131,18 @@ namespace NifOsg
 
             const auto& uvlist = data->uvlist;
             int textureStage = 0;
-            for (const unsigned int uvSet : boundTextures)
+            for (std::vector<unsigned int>::const_iterator it = boundTextures.begin(); it != boundTextures.end(); ++it, ++textureStage)
             {
+                unsigned int uvSet = *it;
                 if (uvSet >= uvlist.size())
                 {
                     Log(Debug::Verbose) << "Out of bounds UV set " << uvSet << " on shape \"" << name << "\" in " << mFilename;
-                    if (!uvlist.empty())
-                        geometry->setTexCoordArray(textureStage, new osg::Vec2Array(uvlist[0].size(), uvlist[0].data()), osg::Array::BIND_PER_VERTEX);
-                    continue;
+                    if (uvlist.empty())
+                        continue;
+                    uvSet = 0;
                 }
 
                 geometry->setTexCoordArray(textureStage, new osg::Vec2Array(uvlist[uvSet].size(), uvlist[uvSet].data()), osg::Array::BIND_PER_VERTEX);
-                textureStage++;
             }
         }
 
@@ -1495,14 +1495,8 @@ namespace NifOsg
                         case Nif::NiTexturingProperty::BumpTexture:
                         case Nif::NiTexturingProperty::DetailTexture:
                         case Nif::NiTexturingProperty::DecalTexture:
-                            break;
                         case Nif::NiTexturingProperty::GlossTexture:
-                        {
-                            // Not used by the vanilla engine. MCP (Morrowind Code Patch) adds an option to use Gloss maps:
-                            // "- Gloss map fix. Morrowind removed gloss map entries from model files after loading them. This stops Morrowind from removing them."
-                            // Log(Debug::Info) << "NiTexturingProperty::GlossTexture in " << mFilename << " not currently used.";
-                            continue;
-                        }
+                            break;
                         default:
                         {
                             Log(Debug::Info) << "Unhandled texture stage " << i << " on shape \"" << nodeName << "\" in " << mFilename;
@@ -1594,6 +1588,12 @@ namespace NifOsg
                         stateset->addUniform(new osg::Uniform("bumpMapMatrix", bumpMapMatrix));
                         stateset->addUniform(new osg::Uniform("envMapLumaBias", texprop->envMapLumaBias));
                     }
+                    else if (i == Nif::NiTexturingProperty::GlossTexture)
+                    {
+                        // A gloss map is an environment map mask.
+                        // Gloss maps are only implemented in the object shaders as well.
+                        stateset->setTextureMode(texUnit, GL_TEXTURE_2D, osg::StateAttribute::OFF);
+                    }
                     else if (i == Nif::NiTexturingProperty::DecalTexture)
                     {
                         // This is only an inaccurate imitation of the original implementation,
@@ -1637,6 +1637,9 @@ namespace NifOsg
                     case Nif::NiTexturingProperty::DecalTexture:
                         texture2d->setName("decalMap");
                         break;
+                    case Nif::NiTexturingProperty::GlossTexture:
+                        texture2d->setName("glossMap");
+                        break;
                     default:
                         break;
                     }
diff --git a/components/shader/shadervisitor.cpp b/components/shader/shadervisitor.cpp
index 107665369c21666374806b1e736664505696d4c1..d8bbeeadc2997a805e3fc61158ede1fe82331fd9 100644
--- a/components/shader/shadervisitor.cpp
+++ b/components/shader/shadervisitor.cpp
@@ -244,7 +244,7 @@ namespace Shader
         addedState->setName("addedState");
     }
 
-    const char* defaultTextures[] = { "diffuseMap", "normalMap", "emissiveMap", "darkMap", "detailMap", "envMap", "specularMap", "decalMap", "bumpMap" };
+    const char* defaultTextures[] = { "diffuseMap", "normalMap", "emissiveMap", "darkMap", "detailMap", "envMap", "specularMap", "decalMap", "bumpMap", "glossMap" };
     bool isTextureNameRecognized(const std::string& name)
     {
         for (unsigned int i=0; i<sizeof(defaultTextures)/sizeof(defaultTextures[0]); ++i)
@@ -325,6 +325,14 @@ namespace Shader
                             {
                                 mRequirements.back().mShaderRequired = true;
                             }
+                            else if (texName == "glossMap")
+                            {
+                                mRequirements.back().mShaderRequired = true;
+                                if (!writableStateSet)
+                                    writableStateSet = getWritableStateSet(node);
+                                // As well as gloss maps
+                                writableStateSet->setTextureMode(unit, GL_TEXTURE_2D, osg::StateAttribute::ON);
+                            }
                         }
                         else
                             Log(Debug::Error) << "ShaderVisitor encountered unknown texture " << texture;
