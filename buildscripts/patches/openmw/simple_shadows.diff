diff --git a/components/sceneutil/mwshadowtechnique.cpp b/components/sceneutil/mwshadowtechnique.cpp
index 3210bf4a4e46a49140f38ec31a47d364aadb3fae..3481e99579a9532541f6f2ae76280985ec68d892 100644
--- a/components/sceneutil/mwshadowtechnique.cpp
+++ b/components/sceneutil/mwshadowtechnique.cpp
@@ -30,6 +30,7 @@
 #include <vector>
 
 #include "shadowsbin.hpp"
+#include <components/debug/debuglog.hpp>
 
 namespace {
 
@@ -552,7 +553,7 @@ MWShadowTechnique::ShadowData::ShadowData(MWShadowTechnique::ViewDependentData*
     else
     {
         _texture->setInternalFormat(GL_DEPTH_COMPONENT);
-        _texture->setShadowComparison(true);
+//        _texture->setShadowComparison(true);
         _texture->setShadowTextureMode(osg::Texture2D::LUMINANCE);
     }
 
@@ -1543,6 +1544,15 @@ void MWShadowTechnique::cull(osgUtil::CullVisitor& cv)
                 {
                     vdsmCallback->getProjectionMatrix()->set(camera->getProjectionMatrix());
                 }
+
+                for (auto& uniform : _uniforms[cv.getTraversalNumber() % 2])
+                {
+                    if (uniform->getName() == "validRegionMatrix" + std::to_string(sm_i))
+                    {
+                        uniform->set((osg::Matrixf)(camera->getViewMatrix() * camera->getProjectionMatrix()));
+                        break;
+                    }
+                }
             }
  
             // 4.4 compute main scene graph TexGen + uniform settings + setup state
@@ -1752,7 +1762,7 @@ void MWShadowTechnique::createShaders()
         _fallbackShadowMapTexture->setWrap(osg::Texture2D::WRAP_T,osg::Texture2D::REPEAT);
         _fallbackShadowMapTexture->setFilter(osg::Texture2D::MIN_FILTER,osg::Texture2D::NEAREST);
         _fallbackShadowMapTexture->setFilter(osg::Texture2D::MAG_FILTER,osg::Texture2D::NEAREST);
-        _fallbackShadowMapTexture->setShadowComparison(true);
+//        _fallbackShadowMapTexture->setShadowComparison(true);
         _fallbackShadowMapTexture->setShadowCompareFunc(osg::Texture::ShadowCompareFunc::ALWAYS);
 
     }
diff --git a/files/shaders/shadows_fragment.glsl b/files/shaders/shadows_fragment.glsl
index 61437099152174552a5e86ea17e614f3c0ed3dd7..295fc4c82932c02636084e9238be47152899e204 100644
--- a/files/shaders/shadows_fragment.glsl
+++ b/files/shaders/shadows_fragment.glsl
@@ -4,7 +4,7 @@
     uniform float maximumShadowMapDistance;
     uniform float shadowFadeStart;
     @foreach shadow_texture_unit_index @shadow_texture_unit_list
-        uniform sampler2DShadow shadowTexture@shadow_texture_unit_index;
+        uniform highp sampler2D shadowTexture@shadow_texture_unit_index;
         varying vec4 shadowSpaceCoords@shadow_texture_unit_index;
 
 #if @perspectiveShadowMaps
@@ -27,13 +27,13 @@ float unshadowedLightRatio(float distance)
         @foreach shadow_texture_unit_index @shadow_texture_unit_list
             if (!doneShadows)
             {
-                vec3 shadowXYZ = shadowSpaceCoords@shadow_texture_unit_index.xyz / shadowSpaceCoords@shadow_texture_unit_index.w;
+                vec3 shadowXYZ = (shadowRegionCoords@shadow_texture_unit_index.xyz / shadowRegionCoords@shadow_texture_unit_index.w) * 0.5 + 0.5;
 #if @perspectiveShadowMaps
-                vec3 shadowRegionXYZ = shadowRegionCoords@shadow_texture_unit_index.xyz / shadowRegionCoords@shadow_texture_unit_index.w;
+                vec3 shadowRegionXYZ = shadowXYZ;
 #endif
                 if (all(lessThan(shadowXYZ.xy, vec2(1.0, 1.0))) && all(greaterThan(shadowXYZ.xy, vec2(0.0, 0.0))))
                 {
-                    shadowing = min(shadow2DProj(shadowTexture@shadow_texture_unit_index, shadowSpaceCoords@shadow_texture_unit_index).r, shadowing);
+                    shadowing = min(texture2D(shadowTexture@shadow_texture_unit_index, shadowRegionXYZ.xy).r, shadowing);
 
                     
                     doneShadows = all(lessThan(shadowXYZ, vec3(0.95, 0.95, 1.0))) && all(greaterThan(shadowXYZ, vec3(0.05, 0.05, 0.0)));
@@ -45,7 +45,7 @@ float unshadowedLightRatio(float distance)
         @endforeach
     #else
         @foreach shadow_texture_unit_index @shadow_texture_unit_list
-            shadowing = min(shadow2DProj(shadowTexture@shadow_texture_unit_index, shadowSpaceCoords@shadow_texture_unit_index).r, shadowing);
+            shadowing = min(texture2D(shadowTexture@shadow_texture_unit_index, shadowSpaceCoords@shadow_texture_unit_index).r, shadowing);
         @endforeach
     #endif
 #if @limitShadowMapDistance
diff --git a/files/shaders/shadows_vertex.glsl b/files/shaders/shadows_vertex.glsl
index f96e1a67359a8ae617a269003dcb1e71f02e2826..0e2506b70db8fd29dcad58e0c0ccc5bbb46ec348 100644
--- a/files/shaders/shadows_vertex.glsl
+++ b/files/shaders/shadows_vertex.glsl
@@ -1,5 +1,7 @@
 #define SHADOWS @shadows_enabled
 
+uniform mat4 osg_ViewMatrixInverse;
+
 #if SHADOWS
     @foreach shadow_texture_unit_index @shadow_texture_unit_list
         uniform int shadowTextureUnit@shadow_texture_unit_index;
@@ -9,6 +11,8 @@
         uniform mat4 validRegionMatrix@shadow_texture_unit_index;
         varying vec4 shadowRegionCoords@shadow_texture_unit_index;
 #endif
+
+        uniform mat4 depthSpaceMatrix@shadow_texture_unit_index;
     @endforeach
 
     // Enabling this may reduce peter panning. Probably unnecessary.
@@ -18,36 +22,42 @@
 void setupShadowCoords(vec4 viewPos, vec3 viewNormal)
 {
 #if SHADOWS
+
+    mat4 model = osg_ViewMatrixInverse * gl_ModelViewMatrix;
+
     // This matrix has the opposite handedness to the others used here, so multiplication must have the vector to the left. Alternatively it could be transposed after construction, but that's extra work for the GPU just to make the code look a tiny bit cleaner.
     mat4 eyePlaneMat;
     vec4 shadowOffset;
     @foreach shadow_texture_unit_index @shadow_texture_unit_list
-        eyePlaneMat = mat4(gl_EyePlaneS[shadowTextureUnit@shadow_texture_unit_index], gl_EyePlaneT[shadowTextureUnit@shadow_texture_unit_index], gl_EyePlaneR[shadowTextureUnit@shadow_texture_unit_index], gl_EyePlaneQ[shadowTextureUnit@shadow_texture_unit_index]);
+//        eyePlaneMat = mat4(gl_EyePlaneS[shadowTextureUnit@shadow_texture_unit_index], gl_EyePlaneT[shadowTextureUnit@shadow_texture_unit_index], gl_EyePlaneR[shadowTextureUnit@shadow_texture_unit_index], gl_EyePlaneQ[shadowTextureUnit@shadow_texture_unit_index]);
 
-#if @perspectiveShadowMaps
-        shadowRegionCoords@shadow_texture_unit_index = validRegionMatrix@shadow_texture_unit_index * viewPos;
-#endif
+//#if @perspectiveShadowMaps
+//        shadowRegionCoords@shadow_texture_unit_index = validRegionMatrix@shadow_texture_unit_index * viewPos;
+//#endif
         
-#if @disableNormalOffsetShadows
-        shadowSpaceCoords@shadow_texture_unit_index = viewPos * eyePlaneMat;
-#else
-        shadowOffset = vec4(viewNormal * @shadowNormalOffset, 0.0);
-
-        if (onlyNormalOffsetUV)
-        {
-            shadowSpaceCoords@shadow_texture_unit_index = viewPos * eyePlaneMat;
-
-            vec4 lightSpaceXY = viewPos + shadowOffset;
-            lightSpaceXY = lightSpaceXY * eyePlaneMat;
-
-            shadowSpaceCoords@shadow_texture_unit_index.xy = lightSpaceXY.xy;
-        }
-        else
-        {
-            vec4 offsetViewPosition = viewPos + shadowOffset;
-            shadowSpaceCoords@shadow_texture_unit_index = offsetViewPosition * eyePlaneMat;
-        }
-#endif
+//#if @disableNormalOffsetShadows
+//        shadowSpaceCoords@shadow_texture_unit_index = viewPos * eyePlaneMat;
+//#else
+//        shadowOffset = vec4(viewNormal * @shadowNormalOffset, 0.0);
+
+//        if (onlyNormalOffsetUV)
+//        {
+//            shadowSpaceCoords@shadow_texture_unit_index = viewPos * eyePlaneMat;
+
+//            vec4 lightSpaceXY = viewPos + shadowOffset;
+//            lightSpaceXY = lightSpaceXY * eyePlaneMat;
+
+//            shadowSpaceCoords@shadow_texture_unit_index.xy = lightSpaceXY.xy;
+//        }
+//        else
+//        {
+//            vec4 offsetViewPosition = viewPos + shadowOffset;
+//            shadowSpaceCoords@shadow_texture_unit_index = offsetViewPosition * eyePlaneMat;
+//        }
+//#endif
+
+    shadowRegionCoords@shadow_texture_unit_index = ((validRegionMatrix@shadow_texture_unit_index * model) * vec4(gl_Vertex.xyz, 1.0));
+
     @endforeach
 #endif // SHADOWS
 }
\ No newline at end of file
diff --git a/files/shaders/groundcover_vertex.glsl b/files/shaders/groundcover_vertex.glsl
index aa9dea33550a6e5b71868b68158732e57e83e49e..7648fb12ae880d2a13cd5b99c690a8edb7b5afe2 100644
--- a/files/shaders/groundcover_vertex.glsl
+++ b/files/shaders/groundcover_vertex.glsl
@@ -45,7 +45,7 @@ varying vec3 passNormal;
 #include "depth.glsl"
 
 uniform float osg_SimulationTime;
-uniform mat4 osg_ViewMatrixInverse;
+//uniform mat4 osg_ViewMatrixInverse;
 uniform mat4 osg_ViewMatrix;
 uniform float windSpeed;
 uniform vec3 playerPos;
