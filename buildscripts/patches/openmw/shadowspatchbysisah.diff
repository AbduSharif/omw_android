diff --git a/apps/openmw/mwrender/renderingmanager.cpp b/apps/openmw/mwrender/renderingmanager.cpp
index fb189221132..2b4c958e6a3 100644
--- a/apps/openmw/mwrender/renderingmanager.cpp
+++ b/apps/openmw/mwrender/renderingmanager.cpp
@@ -419,6 +419,8 @@ namespace MWRender
 
         globalDefines["reverseZ"] = reverseZ ? "1" : "0";
 
+        globalDefines["shadowMapSize"] = std::to_string(Settings::shadows().mShadowMapResolution);
+
         // It is unnecessary to stop/start the viewer as no frames are being rendered yet.
         mResourceSystem->getSceneManager()->getShaderManager().setGlobalDefines(globalDefines);
 
diff --git a/components/sceneutil/mwshadowtechnique.cpp b/components/sceneutil/mwshadowtechnique.cpp
index 06930ebe595..7ee6d636885 100644
--- a/components/sceneutil/mwshadowtechnique.cpp
+++ b/components/sceneutil/mwshadowtechnique.cpp
@@ -554,8 +554,8 @@ MWShadowTechnique::ShadowData::ShadowData(MWShadowTechnique::ViewDependentData*
         _texture->setShadowTextureMode(osg::Texture2D::LUMINANCE);
     }
 
-    _texture->setFilter(osg::Texture2D::MIN_FILTER,osg::Texture2D::LINEAR);
-    _texture->setFilter(osg::Texture2D::MAG_FILTER,osg::Texture2D::LINEAR);
+    _texture->setFilter(osg::Texture2D::MIN_FILTER,osg::Texture2D::NEAREST);
+    _texture->setFilter(osg::Texture2D::MAG_FILTER,osg::Texture2D::NEAREST);
 
     // the shadow comparison should fail if object is outside the texture
     _texture->setWrap(osg::Texture2D::WRAP_S,osg::Texture2D::CLAMP_TO_BORDER);
diff --git a/files/shaders/compatibility/shadows_fragment.glsl b/files/shaders/compatibility/shadows_fragment.glsl
index 2945edff3dc..08a53248ff9 100644
--- a/files/shaders/compatibility/shadows_fragment.glsl
+++ b/files/shaders/compatibility/shadows_fragment.glsl
@@ -4,7 +4,7 @@
     uniform float maximumShadowMapDistance;
     uniform float shadowFadeStart;
     @foreach shadow_texture_unit_index @shadow_texture_unit_list
-        uniform sampler2DShadow shadowTexture@shadow_texture_unit_index;
+        uniform sampler2D shadowTexture@shadow_texture_unit_index;
         varying vec4 shadowSpaceCoords@shadow_texture_unit_index;
 
 #if @perspectiveShadowMaps
@@ -13,6 +13,24 @@
     @endforeach
 #endif // SHADOWS
 
+float CalcShadowFactor(sampler2D shadowTexture, vec4 LightSpacePos)
+{
+    vec3 shadowCoordsProj = LightSpacePos.xyz / LightSpacePos.w;
+    float Offset = 1.0/@shadowMapSize.0;
+    float Factor;
+
+    for (int y = -1; y <= 1; y++) {
+        for (int x = -1; x <= 1; x++) {
+            vec2 Offsets = vec2(float(x) * Offset, float(y) * Offset);
+            float shadowDistance = texture2D(shadowTexture, shadowCoordsProj.xy + Offsets).r;
+            if (shadowDistance >= shadowCoordsProj.z - 0.0001)
+                Factor += 1.0;
+        }
+    }
+
+    return Factor / 9.0;
+}
+
 float unshadowedLightRatio(float distance)
 {
     float shadowing = 1.0;
@@ -33,7 +51,7 @@ float unshadowedLightRatio(float distance)
 #endif
                 if (all(lessThan(shadowXYZ.xy, vec2(1.0, 1.0))) && all(greaterThan(shadowXYZ.xy, vec2(0.0, 0.0))))
                 {
-                    shadowing = min(shadow2DProj(shadowTexture@shadow_texture_unit_index, shadowSpaceCoords@shadow_texture_unit_index).r, shadowing);
+                    shadowing = CalcShadowFactor(shadowTexture@shadow_texture_unit_index, shadowSpaceCoords@shadow_texture_unit_index);
 
                     doneShadows = all(lessThan(shadowXYZ, vec3(0.95, 0.95, 1.0))) && all(greaterThan(shadowXYZ, vec3(0.05, 0.05, 0.0)));
 #if @perspectiveShadowMaps
@@ -44,7 +62,7 @@ float unshadowedLightRatio(float distance)
         @endforeach
     #else
         @foreach shadow_texture_unit_index @shadow_texture_unit_list
-            shadowing = min(shadow2DProj(shadowTexture@shadow_texture_unit_index, shadowSpaceCoords@shadow_texture_unit_index).r, shadowing);
+            shadowing = CalcShadowFactor(shadowTexture@shadow_texture_unit_index, shadowSpaceCoords@shadow_texture_unit_index);
         @endforeach
     #endif
 #if @limitShadowMapDistance
@@ -84,4 +102,4 @@ void applyShadowDebugOverlay()
         }
     @endforeach
 #endif // SHADOWS
-}
\ No newline at end of file
+}
