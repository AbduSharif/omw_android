diff --git a/apps/openmw/CMakeLists.txt b/apps/openmw/CMakeLists.txt
index 0ccb517a338b94f6bc77cc3c9846d084ddae3ea5..1508c50aa05edd58374a23b13eb454a76724758d 100644
--- a/apps/openmw/CMakeLists.txt
+++ b/apps/openmw/CMakeLists.txt
@@ -61,7 +61,7 @@ add_openmw_dir (mwscript
 add_openmw_dir (mwlua
     luamanagerimp object worldview userdataserializer eventqueue
     luabindings localscripts playerscripts objectbindings cellbindings asyncbindings settingsbindings
-    camerabindings uibindings inputbindings nearbybindings postprocessingbindings stats debugbindings
+    camerabindings uibindings inputbindings nearbybindings postprocessingbindings stats debugbindings weatherbindings
     types/types types/door types/actor types/container types/weapon types/npc types/creature types/activator types/book types/lockpick types/probe
     )
 
diff --git a/apps/openmw/mwlua/luabindings.hpp b/apps/openmw/mwlua/luabindings.hpp
index af41199ad9e474221feb8ff76496625f43ef27b7..8378d878f2f0f9ca28f1b33711d8cfda8b526c84 100644
--- a/apps/openmw/mwlua/luabindings.hpp
+++ b/apps/openmw/mwlua/luabindings.hpp
@@ -22,6 +22,7 @@ namespace MWLua
     sol::table initCorePackage(const Context&);
     sol::table initWorldPackage(const Context&);
     sol::table initPostprocessingPackage(const Context&);
+    sol::table initWeatherPackage(const Context&);
 
     sol::table initGlobalStoragePackage(const Context&, LuaUtil::LuaStorage* globalStorage);
     sol::table initLocalStoragePackage(const Context&, LuaUtil::LuaStorage* globalStorage);
diff --git a/apps/openmw/mwlua/luamanagerimp.cpp b/apps/openmw/mwlua/luamanagerimp.cpp
index 6894208c07169e2fd4db10d836818ce0c94cc3bb..322bc013b19d1c21b979a3b276ee05254d01cf23 100644
--- a/apps/openmw/mwlua/luamanagerimp.cpp
+++ b/apps/openmw/mwlua/luamanagerimp.cpp
@@ -98,6 +98,7 @@ namespace MWLua
         mPlayerStoragePackage = initPlayerStoragePackage(localContext, &mGlobalStorage, &mPlayerStorage);
         mPostprocessingPackage = initPostprocessingPackage(localContext);
         mDebugPackage = initDebugPackage(localContext);
+        mWeatherPackage = initWeatherPackage(localContext);
 
         initConfiguration();
         mInitialized = true;
@@ -427,6 +428,7 @@ namespace MWLua
             scripts->addPackage("openmw.settings", mLocalSettingsPackage);
             scripts->addPackage("openmw.storage", mLocalStoragePackage);
         }
+        scripts->addPackage("openmw.weather", mWeatherPackage);
         scripts->addPackage("openmw.nearby", mNearbyPackage);
         scripts->setSerializer(mLocalSerializer.get());
 
diff --git a/apps/openmw/mwlua/luamanagerimp.hpp b/apps/openmw/mwlua/luamanagerimp.hpp
index 871ab0af262c5b30e7d034c4137a03c6cb5e5444..b6792dfcbf24a7f35ce4e8b7a1712b186577ef81 100644
--- a/apps/openmw/mwlua/luamanagerimp.hpp
+++ b/apps/openmw/mwlua/luamanagerimp.hpp
@@ -142,6 +142,7 @@ namespace MWLua
         sol::table mPlayerStoragePackage;
         sol::table mPostprocessingPackage;
         sol::table mDebugPackage;
+        sol::table mWeatherPackage;
 
         GlobalScripts mGlobalScripts{&mLua};
         std::set<LocalScripts*> mActiveLocalScripts;
diff --git a/apps/openmw/mwlua/weatherbindings.cpp b/apps/openmw/mwlua/weatherbindings.cpp
new file mode 100644
index 0000000000000000000000000000000000000000..6f2e3e9984d03dd02a0019dea58c95b15e44d7ec
--- /dev/null
+++ b/apps/openmw/mwlua/weatherbindings.cpp
@@ -0,0 +1,20 @@
+#include "context.hpp"
+#include "luamanagerimp.hpp"
+
+#include "../mwbase/environment.hpp"
+#include "../mwbase/world.hpp"
+#include "../mwrender/renderingmanager.hpp"
+
+#include <components/lua/luastate.hpp>
+
+namespace MWLua
+{
+    sol::table initWeatherPackage(const Context& context)
+    {
+        sol::table api = context.mLua->newTable();
+
+        // auto fog = context.mLua->sol().new_usertype<Fog>("UiContent");
+
+        return LuaUtil::makeReadOnly(api);
+    }
+}
diff --git a/apps/openmw/mwrender/renderingmanager.cpp b/apps/openmw/mwrender/renderingmanager.cpp
index e0869a45dd061b6bb9ef8697432a228de3a28d0b..b19890ce1e8128552d921d81c1f65330c4ae3216 100644
--- a/apps/openmw/mwrender/renderingmanager.cpp
+++ b/apps/openmw/mwrender/renderingmanager.cpp
@@ -141,10 +141,12 @@ namespace MWRender
 
         void setDefaults(osg::StateSet* stateset) override
         {
-            stateset->addUniform(new osg::Uniform("linearFac", 0.f));
-            stateset->addUniform(new osg::Uniform("near", 0.f));
-            stateset->addUniform(new osg::Uniform("far", 0.f));
-            stateset->addUniform(new osg::Uniform("screenRes", osg::Vec2f{}));
+            stateset->addUniform(new osg::Uniform("linearFac", mLinearFac));
+            stateset->addUniform(new osg::Uniform("near", mNear));
+            stateset->addUniform(new osg::Uniform("far", mFar));
+            stateset->addUniform(new osg::Uniform("screenRes", mScreenRes));
+            stateset->addUniform(new osg::Uniform("skyColor", mSkyColor));
+
             if (mUsePlayerUniforms)
             {
                 stateset->addUniform(new osg::Uniform("windSpeed", 0.0f));
@@ -154,31 +156,15 @@ namespace MWRender
 
         void apply(osg::StateSet* stateset, osg::NodeVisitor* nv) override
         {
-            auto* uLinearFac = stateset->getUniform("linearFac");
-            if (uLinearFac)
-                uLinearFac->set(mLinearFac);
-
-            auto* uNear = stateset->getUniform("near");
-            if (uNear)
-                uNear->set(mNear);
-
-            auto* uFar = stateset->getUniform("far");
-            if (uFar)
-                uFar->set(mFar);
-
-            auto* uScreenRes = stateset->getUniform("screenRes");
-            if (uScreenRes)
-                uScreenRes->set(mScreenRes);
-
+            stateset->getUniform("linearFac")->set(mLinearFac);
+            stateset->getUniform("near")->set(mNear);
+            stateset->getUniform("far")->set(mFar);
+            stateset->getUniform("screenRes")->set(mScreenRes);
+            stateset->getUniform("skyColor")->set(mSkyColor);
             if (mUsePlayerUniforms)
             {
-                auto* windSpeed = stateset->getUniform("windSpeed");
-                if (windSpeed)
-                    windSpeed->set(mWindSpeed);
-
-                auto* playerPos = stateset->getUniform("playerPos");
-                if (playerPos)
-                    playerPos->set(mPlayerPos);
+                stateset->getUniform("windSpeed")->set(mWindSpeed);
+                stateset->getUniform("playerPos")->set(mPlayerPos);
             }
         }
 
@@ -212,12 +198,18 @@ namespace MWRender
             mPlayerPos = playerPos;
         }
 
+        void setSkyColor(const osg::Vec4f& color)
+        {
+            mSkyColor = color;
+        }
+
     private:
         float mLinearFac;
         float mNear;
         float mFar;
         bool mUsePlayerUniforms;
         float mWindSpeed;
+        osg::Vec4f mSkyColor;
         osg::Vec3f mPlayerPos;
         osg::Vec2f mScreenRes;
     };
@@ -898,6 +890,8 @@ namespace MWRender
         auto world = MWBase::Environment::get().getWorld();
         const auto& stateUpdater = mPostProcessor->getStateUpdater();
 
+        mSharedUniformStateUpdater->setSkyColor(mSky->getSkyColor()); 
+
         stateUpdater->setFogRange(fogStart, fogEnd);
         stateUpdater->setNearFar(mNearClip, mViewDistance);
         stateUpdater->setIsUnderwater(isUnderwater);
diff --git a/apps/openmw/mwrender/sky.hpp b/apps/openmw/mwrender/sky.hpp
index 1fdf476bd5740d5c13bfa6cfc944913c787279b0..cb840e0f532c5e566de059aff1e77ec41cc45d2a 100644
--- a/apps/openmw/mwrender/sky.hpp
+++ b/apps/openmw/mwrender/sky.hpp
@@ -98,6 +98,8 @@ namespace MWRender
 
         void setSunglare(bool enabled);
 
+        osg::Vec4f getSkyColor() const { return mSkyColour; }
+
     private:
         void create();
         ///< no need to call this, automatically done on first enable()
diff --git a/files/shaders/CMakeLists.txt b/files/shaders/CMakeLists.txt
index 88fd6d45ca10f2874a1e475c9d3e9d742120dd45..affb3fc940e2ff54905db4de3f24ee39811d0058 100644
--- a/files/shaders/CMakeLists.txt
+++ b/files/shaders/CMakeLists.txt
@@ -52,6 +52,7 @@ set(SHADER_FILES
     hdr_luminance_fragment.glsl
     fullscreen_tri_vertex.glsl
     fullscreen_tri_fragment.glsl
+    fog.glsl
 )
 
 copy_all_resource_files(${CMAKE_CURRENT_SOURCE_DIR} ${OPENMW_RESOURCES_ROOT} ${DDIRRELATIVE} "${SHADER_FILES}")
diff --git a/files/shaders/fog.glsl b/files/shaders/fog.glsl
new file mode 100644
index 0000000000000000000000000000000000000000..840273a7ed8cd328594c4b98385eb21007282144
--- /dev/null
+++ b/files/shaders/fog.glsl
@@ -0,0 +1,96 @@
+#define FOG_LINEAR 0
+#define FOG_RADIAL 1
+#define FOG_SCATTERING 2
+
+vec3 fogColFar = gl_Fog.color.rgb;
+
+uniform vec4 skyColor;
+
+// PRECOMPUTE, these 4 are equal with standard fog
+const float expFogDistScale = 4.4;
+float fogExpStart = gl_Fog.start / expFogDistScale;
+float fogExpDivisor = (gl_Fog.end - fogExpStart) / expFogDistScale;
+
+float nearFogStart = fogExpStart;
+float nearFogRange = fogExpDivisor;
+
+// these are actual uniforms?
+float fogstart = 2000.0;
+float fogrange = 10000.0;
+
+///////////////////////////////////////////////
+
+// TODO: These should be uniforms
+const vec3 outscatter = vec3(0.07, 0.36, 0.76);
+const vec3 inscatter = vec3(0.25, 0.38, 0.48);
+
+// TODO: These should as well, all can be pre-computed
+vec4 newSkyColor = mix(skyColor, vec4(0.371, 0.637, 1.108, 0), 0.62);
+
+vec3 sunPos = normalize(lcalcPosition(0).xzy);
+
+float sunaltitude = pow(1.0 + sunPos.z, 10.0);
+float sunaltitude_a = 2.8 + 4.3 / sunaltitude;
+float sunaltitude_b = clamp(1 - exp2(-1.9 * sunaltitude), 0.0, 1.0);
+float sunaltitude_c = clamp(exp(-4 * sunPos.z), 0.0, 1.0) * clamp(sunaltitude, 0.0, 1.0);
+
+///////////////////////////////////////////////
+
+vec3 applyFog(vec3 color, vec4 fog)
+{
+    return fog.a * color.rgb + fog.rgb;
+}
+
+vec4 fogColourScatter(vec3 dir, float fogdist, float fog, vec3 skyColDirectional)
+{
+    skyColDirectional *= 1.0 - fog;
+
+    float suncos = dot(dir, sunPos);
+    float mie = (1.58 / (1.24 - suncos)) * sunaltitude_c;
+    float rayl = 1.0 - 0.09 * mie;
+
+    float atmdep = 1.33 * exp(-2.0 * clamp(dir.z, 0.0, 1.0));
+    vec3 sunscatter = mix(inscatter, outscatter, 0.5 * (1.0 + suncos));
+    vec3 att = atmdep * sunscatter * (sunaltitude_a + 0.7 * mie);
+    att = (1 - exp(-fogdist * att)) / att;
+
+    vec3 color = 0.125 * mie + newSkyColor.rgb * rayl;
+    color *= att * (1.17 * atmdep + 0.89) * sunaltitude_b;
+    color = mix(skyColDirectional, color, 0.5);
+
+    return vec4(color, fog);
+}
+
+// TODO: replace with standard fog calculations (radial)
+float fogMWScalar(float dist)
+{
+    return clamp((nearFogRange - dist) / (nearFogRange - nearFogStart), 0.0, 1.0);
+}
+
+vec4 fogColour(vec3 dir, float dist)
+{
+    float fogdist = (dist - fogstart) / fogrange;
+    float fog = 0.0;
+    if (dist > far)
+        fog = clamp(exp(-fogdist), 0.0, 1.0);
+    else
+        fog = fogMWScalar(dist);
+    fogdist = clamp(0.224 * fogdist, 0.0, 1.0);
+
+    return fogColourScatter(dir, fogdist, fog, fogColFar);
+}
+
+vec4 fogColourSky(vec3 dir)
+{
+    vec3 skyColDirectional = mix(fogColFar, skyColor.rgb, 1 - pow(clamp(1 - 2.22 * clamp(dir.z - 0.075, 0.0, 1.0), 0.0, 1.0), 1.15));
+    return fogColourScatter(dir, 1, 0, skyColDirectional);
+}
+
+vec4 fogColourWater(vec3 dir, float dist)
+{
+    float fogdist = (dist - fogstart) / fogrange;
+    float fog = clamp(exp(-fogdist), 0.0, 1.0);
+    fogdist = clamp(0.224 * fogdist, 0.0, 1.0);
+
+    return fogColourScatter(dir, fogdist, fog, fogColFar);
+}
\ No newline at end of file
diff --git a/files/shaders/groundcover_fragment.glsl b/files/shaders/groundcover_fragment.glsl
index b7ff102079c233b77320ebaaf36804e0c214e6c8..5ca0049848b26d7c19e846190ac9492ae8874512 100644
--- a/files/shaders/groundcover_fragment.glsl
+++ b/files/shaders/groundcover_fragment.glsl
@@ -27,19 +27,22 @@ varying vec4 passTangent;
 
 varying float euclideanDepth;
 varying float linearDepth;
-
-#if PER_PIXEL_LIGHTING
 varying vec3 passViewPos;
-#else
+
+#if !PER_PIXEL_LIGHTING
 centroid varying vec3 passLighting;
 centroid varying vec3 shadowDiffuseLighting;
 #endif
 
 varying vec3 passNormal;
 
+uniform float near;
+uniform float far;
+
 #include "shadows_fragment.glsl"
 #include "lighting.glsl"
 #include "alpha.glsl"
+#include "fog.glsl"
 
 void main()
 {
@@ -83,6 +86,11 @@ void main()
 
     gl_FragData[0].xyz *= lighting;
 
+    float dist = length(passViewPos);
+    vec4 fog = fogColour(passViewPos / dist, dist);
+    gl_FragData[0].rgb = applyFog(gl_FragData[0].rgb, fog);
+
+#if 0
 #if @radialFog
     float fogValue = clamp((euclideanDepth - gl_Fog.start) * gl_Fog.scale, 0.0, 1.0);
 #else
@@ -92,6 +100,7 @@ void main()
 
 #if !@disableNormals
     gl_FragData[1].xyz = worldNormal * 0.5 + 0.5;
+#endif
 #endif
 
     applyShadowDebugOverlay();
diff --git a/files/shaders/groundcover_vertex.glsl b/files/shaders/groundcover_vertex.glsl
index aa9dea33550a6e5b71868b68158732e57e83e49e..45586e145c3054a75ac113c32692f60fcd5df584 100644
--- a/files/shaders/groundcover_vertex.glsl
+++ b/files/shaders/groundcover_vertex.glsl
@@ -30,10 +30,9 @@ varying vec4 passTangent;
 
 varying float euclideanDepth;
 varying float linearDepth;
-
-#if PER_PIXEL_LIGHTING
 varying vec3 passViewPos;
-#else
+
+#if !PER_PIXEL_LIGHTING
 centroid varying vec3 passLighting;
 centroid varying vec3 shadowDiffuseLighting;
 #endif
@@ -163,9 +162,8 @@ void main(void)
 #endif
 
     passNormal = rotation3(rotation) * gl_Normal.xyz;
-#if PER_PIXEL_LIGHTING
     passViewPos = viewPos.xyz;
-#else
+#if !PER_PIXEL_LIGHTING
     vec3 diffuseLight, ambientLight;
     doLighting(viewPos.xyz, viewNormal, diffuseLight, ambientLight, shadowDiffuseLighting);
     passLighting = diffuseLight + ambientLight;
diff --git a/files/shaders/objects_fragment.glsl b/files/shaders/objects_fragment.glsl
index 16cbf9bbbd8db85ba182b06d7008675dcddef274..1a0575486e12a529232e14a070c0e4dea82b7316 100644
--- a/files/shaders/objects_fragment.glsl
+++ b/files/shaders/objects_fragment.glsl
@@ -64,6 +64,9 @@ varying vec2 glossMapUV;
 #endif
 
 uniform bool simpleWater;
+uniform float near;
+uniform float far;
+uniform vec2 screenRes;
 
 varying float euclideanDepth;
 varying float linearDepth;
@@ -90,6 +93,8 @@ varying vec3 passNormal;
 #include "softparticles.glsl"
 #endif
 
+#include "fog.glsl"
+
 void main()
 {
 #if @diffuseMap
@@ -230,6 +235,12 @@ void main()
 #endif
         gl_FragData[0].xyz += getSpecular(normalize(viewNormal), normalize(passViewPos.xyz), shininess, matSpec) * shadowing;
     }
+
+    float dist = length(passViewPos);
+    vec4 fog = fogColour(passViewPos / dist, dist);
+    gl_FragData[0].rgb = applyFog(gl_FragData[0].rgb, fog);
+
+#if 0
 #if @radialFog
     float depth;
     // For the less detailed mesh of simple water we need to recalculate depth on per-pixel basis
@@ -242,6 +253,7 @@ void main()
     float fogValue = clamp((linearDepth - gl_Fog.start) * gl_Fog.scale, 0.0, 1.0);
 #endif
     gl_FragData[0].xyz = mix(gl_FragData[0].xyz, gl_Fog.color.xyz, fogValue);
+#endif
 
 #if !defined(FORCE_OPAQUE) && @softParticles
     gl_FragData[0].a *= calcSoftParticleFade();
diff --git a/files/shaders/sky_fragment.glsl b/files/shaders/sky_fragment.glsl
index cfa3650c02d845355dde601978b716a5ce271794..8748d0998fd3ed48bd9d2aba76f342712991f473 100644
--- a/files/shaders/sky_fragment.glsl
+++ b/files/shaders/sky_fragment.glsl
@@ -1,6 +1,12 @@
 #version 120
 
-#include "skypasses.glsl"
+#if @useUBO
+    #extension GL_ARB_uniform_buffer_object : require
+#endif
+
+#if @useGPUShader4
+    #extension GL_EXT_gpu_shader4: require
+#endif
 
 uniform int pass;
 uniform sampler2D diffuseMap;
@@ -8,14 +14,28 @@ uniform sampler2D maskMap;      // PASS_MOON
 uniform float opacity;          // PASS_CLOUDS, PASS_ATMOSPHERE_NIGHT
 uniform vec4 moonBlend;         // PASS_MOON
 uniform vec4 atmosphereFade;    // PASS_MOON
+uniform float near;
+uniform float far;
 
 varying vec2 diffuseMapUV;
 varying vec4 passColor;
+varying vec3 passPos;
+
+#include "skypasses.glsl"
+#include "lighting.glsl"
+#include "fog.glsl"
+
+const mat4 ditherSky = mat4( 0.001176,  0.001961, -0.001176, -0.001699,
+                            -0.000654, -0.000915,  0.000392,  0.000131,
+                            -0.000131, -0.001961,  0.000654,  0.000915,
+                             0.001699,  0.001438, -0.000392, -0.001438);
 
 void paintAtmosphere(inout vec4 color)
 {
-    color = gl_FrontMaterial.emission;
-    color.a *= passColor.a;
+    // color = gl_FrontMaterial.emission;
+    // color.a *= passColor.a;
+    color = fogColourSky(normalize(passPos)) + ditherSky[int(gl_FragCoord.x) % 4][int(gl_FragCoord.y) % 4];
+    color.a = 1.0;
 }
 
 void paintAtmosphereNight(inout vec4 color)
@@ -31,7 +51,10 @@ void paintClouds(inout vec4 color)
     color.xyz = clamp(color.xyz * gl_FrontMaterial.emission.xyz, 0.0, 1.0);
 
     // ease transition between clear color and atmosphere/clouds
-    color = mix(vec4(gl_Fog.color.xyz, color.a), color, passColor.a);
+    // color = mix(vec4(gl_Fog.color.xyz, color.a), color, passColor.a);
+
+    vec4 fog = fogColourSky(normalize(passPos)) + ditherSky[int(gl_FragCoord.x) % 4][int(gl_FragCoord.y) % 4];
+    color = mix(vec4(color.xyz, color.a), color, passColor.a);
 }
 
 void paintMoon(inout vec4 color)
diff --git a/files/shaders/sky_vertex.glsl b/files/shaders/sky_vertex.glsl
index 8ff9c0f15615aebcdf7e918bd78b9ebeb0e851dc..971686f2ac23befca5070164c0e5b10c788ea940 100644
--- a/files/shaders/sky_vertex.glsl
+++ b/files/shaders/sky_vertex.glsl
@@ -8,11 +8,20 @@ uniform int pass;
 
 varying vec4 passColor;
 varying vec2 diffuseMapUV;
+varying vec3 passPos;
+
+uniform mat4 osg_ViewMatrixInverse;
 
 void main()
 {
-    gl_Position = mw_modelToClip(gl_Vertex);
+    vec4 vertex = gl_Vertex;
+
+    if (pass == PASS_ATMOSPHERE)
+        vertex.z -= 200.0;
+
+    gl_Position = mw_modelToClip(vertex);
     passColor = gl_Color;
+    passPos = vec3(osg_ViewMatrixInverse * gl_ModelViewMatrix * gl_Vertex).xyz;
 
     if (pass == PASS_CLOUDS)
         diffuseMapUV = (gl_TextureMatrix[0] * gl_MultiTexCoord0).xy;
diff --git a/files/shaders/softparticles.glsl b/files/shaders/softparticles.glsl
index fa8b4de4c118c7d0c14f5d92a7352f022d9306bd..742a2a3d3a0e1cdf59d43fd98d315955650f5afa 100644
--- a/files/shaders/softparticles.glsl
+++ b/files/shaders/softparticles.glsl
@@ -1,7 +1,4 @@
-uniform float near;
-uniform float far;
 uniform sampler2D opaqueDepthTex;
-uniform vec2 screenRes;
 uniform float particleSize;
 
 float viewDepth(float depth)
diff --git a/files/shaders/terrain_fragment.glsl b/files/shaders/terrain_fragment.glsl
index 7ff696e0833b244eb6c2ceccc4e8593f85e6842c..1fc2d4a9598cd80f2c13b379154895e88733d14e 100644
--- a/files/shaders/terrain_fragment.glsl
+++ b/files/shaders/terrain_fragment.glsl
@@ -32,10 +32,14 @@ centroid varying vec3 shadowDiffuseLighting;
 varying vec3 passViewPos;
 varying vec3 passNormal;
 
+uniform float near;
+uniform float far;
+
 #include "vertexcolors.glsl"
 #include "shadows_fragment.glsl"
 #include "lighting.glsl"
 #include "parallax.glsl"
+#include "fog.glsl"
 
 void main()
 {
@@ -116,6 +120,11 @@ void main()
         gl_FragData[0].xyz += getSpecular(normalize(viewNormal), normalize(passViewPos), shininess, matSpec) * shadowing;
     }
 
+    float dist = length(passViewPos);
+    vec4 fog = fogColour(passViewPos / dist, dist);
+    gl_FragData[0].rgb = applyFog(gl_FragData[0].rgb, fog);
+
+#if 0
 #if @radialFog
     float fogValue = clamp((euclideanDepth - gl_Fog.start) * gl_Fog.scale, 0.0, 1.0);
 #else
@@ -125,6 +134,7 @@ void main()
 
 #if !@disableNormals && @writeNormals
     gl_FragData[1].xyz = worldNormal.xyz * 0.5 + 0.5;
+#endif
 #endif
 
     applyShadowDebugOverlay();
diff --git a/files/shaders/water_fragment.glsl b/files/shaders/water_fragment.glsl
index 51d30be2d4a574df0c7d18c96aec7e0b580df25e..92e2dfe66dd8f43c2b9f44209adf37df2807737e 100644
--- a/files/shaders/water_fragment.glsl
+++ b/files/shaders/water_fragment.glsl
@@ -206,6 +206,7 @@ vec2 normalCoords(vec2 uv, float scale, float speed, float time, float timer1, f
 
 varying vec4 position;
 varying float linearDepth;
+varying vec3 passViewPos;
 
 uniform sampler2D normalMap;
 
@@ -223,6 +224,7 @@ uniform vec2 screenRes;
 
 #include "shadows_fragment.glsl"
 #include "lighting.glsl"
+#include "fog.glsl"
 
 float frustumDepth;
 
@@ -355,7 +357,11 @@ void main(void)
     gl_FragData[0].w = clamp(fresnel*6.0 + specular * sunSpec.w, 0.0, 1.0);     //clamp(fresnel*2.0 + specular * gl_LightSource[0].specular.w, 0.0, 1.0);
 #endif
 
-    // fog
+    float dist = length(passViewPos);
+    vec4 fog = fogColour(passViewPos / dist, dist);
+    gl_FragData[0].rgb = applyFog(gl_FragData[0].rgb, fog);
+
+#if 0
 #if @radialFog
     float fogValue = clamp((radialDepth - gl_Fog.start) * gl_Fog.scale, 0.0, 1.0);
 #else
@@ -365,6 +371,7 @@ void main(void)
 
 #if !@disableNormals
     gl_FragData[1].rgb = normal * 0.5 + 0.5;
+#endif
 #endif
 
     applyShadowDebugOverlay();
diff --git a/files/shaders/water_vertex.glsl b/files/shaders/water_vertex.glsl
index b09d3b54aed41a580bf18b03b4f6b8967c56955c..ad43600a34039e1647891877dad3641b956d7146 100644
--- a/files/shaders/water_vertex.glsl
+++ b/files/shaders/water_vertex.glsl
@@ -4,6 +4,7 @@
 
 varying vec4  position;
 varying float linearDepth;
+varying vec3 passViewPos;
 
 #include "shadows_vertex.glsl"
 #include "depth.glsl"
@@ -15,6 +16,7 @@ void main(void)
     position = gl_Vertex;
 
     vec4 viewPos = mw_modelToView(gl_Vertex);
+    passViewPos = viewPos.xyz;
     linearDepth = getLinearDepth(gl_Position.z, viewPos.z);
 
     setupShadowCoords(viewPos, normalize((gl_NormalMatrix * gl_Normal).xyz));
