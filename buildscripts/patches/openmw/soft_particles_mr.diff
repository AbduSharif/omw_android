diff --git a/CHANGELOG.md b/CHANGELOG.md
index 7a486046e84515393c8e9aea646214cc03cf0b87..65110a067700b691a94cf7730a20dfd6e887cc63 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -78,6 +78,7 @@
     Feature #6017: Separate persistent and temporary cell references when saving
     Feature #6032: Reverse-z depth buffer
     Feature #6078: First person should not clear depth buffer
+    Feature #6128: Soft Particles
     Feature #6161: Refactor Sky to use shaders and GLES/GL3 friendly
     Feature #6162: Refactor GUI to use shaders and to be GLES and GL3+ friendly
     Feature #6199: Support FBO Rendering
diff --git a/apps/launcher/advancedpage.cpp b/apps/launcher/advancedpage.cpp
index 2c33992ac39ba3aa0893a614afe95a37f108c9d8..8d1ab58b79ccd515f17329362f6cdf691ed458e6 100644
--- a/apps/launcher/advancedpage.cpp
+++ b/apps/launcher/advancedpage.cpp
@@ -117,6 +117,7 @@ bool Launcher::AdvancedPage::loadSettings()
         loadSettingBool(autoUseTerrainSpecularMapsCheckBox, "auto use terrain specular maps", "Shaders");
         loadSettingBool(bumpMapLocalLightingCheckBox, "apply lighting to environment maps", "Shaders");
         loadSettingBool(radialFogCheckBox, "radial fog", "Shaders");
+        loadSettingBool(softParticlesCheckBox, "soft particles", "Shaders");
         loadSettingBool(magicItemAnimationsCheckBox, "use magic item animations", "Game");
         connect(animSourcesCheckBox, SIGNAL(toggled(bool)), this, SLOT(slotAnimSourcesToggled(bool)));
         loadSettingBool(animSourcesCheckBox, "use additional anim sources", "Game");
@@ -270,6 +271,7 @@ void Launcher::AdvancedPage::saveSettings()
         saveSettingBool(autoUseTerrainSpecularMapsCheckBox, "auto use terrain specular maps", "Shaders");
         saveSettingBool(bumpMapLocalLightingCheckBox, "apply lighting to environment maps", "Shaders");
         saveSettingBool(radialFogCheckBox, "radial fog", "Shaders");
+        saveSettingBool(softParticlesCheckBox, "soft particles", "Shaders");
         saveSettingBool(magicItemAnimationsCheckBox, "use magic item animations", "Game");
         saveSettingBool(animSourcesCheckBox, "use additional anim sources", "Game");
         saveSettingBool(weaponSheathingCheckBox, "weapon sheathing", "Game");
diff --git a/apps/openmw/mwrender/postprocessor.cpp b/apps/openmw/mwrender/postprocessor.cpp
index 1ee5745cb40c9bc44719de7d3b2e59446307d940..7405098a031fea692f118918b35b57877431b84e 100644
--- a/apps/openmw/mwrender/postprocessor.cpp
+++ b/apps/openmw/mwrender/postprocessor.cpp
@@ -93,6 +93,41 @@ namespace
 
         MWRender::PostProcessor* mPostProcessor;
     };
+
+    // Copies the currently bound depth attachment to a new texture so drawables in transparent renderbin can safely sample from depth.
+    class OpaqueDepthCopyCallback : public osgUtil::RenderBin::DrawCallback
+    {
+    public:
+        OpaqueDepthCopyCallback(osg::ref_ptr<osg::Texture2D> opaqueDepthTex, osg::ref_ptr<osg::FrameBufferObject> sourceFbo)
+            : mOpaqueDepthFbo(new osg::FrameBufferObject)
+            , mSourceFbo(sourceFbo)
+            , mOpaqueDepthTex(opaqueDepthTex)
+        {
+            mOpaqueDepthFbo->setAttachment(osg::FrameBufferObject::BufferComponent::DEPTH_BUFFER, osg::FrameBufferAttachment(opaqueDepthTex));
+        }
+
+        void drawImplementation(osgUtil::RenderBin* bin, osg::RenderInfo& renderInfo, osgUtil::RenderLeaf*& previous) override
+        {
+            if (bin->getStage()->getFrameBufferObject() == mSourceFbo)
+            {
+                osg::State& state = *renderInfo.getState();
+                osg::GLExtensions* ext = state.get<osg::GLExtensions>();
+
+                mSourceFbo->apply(state, osg::FrameBufferObject::READ_FRAMEBUFFER);
+                mOpaqueDepthFbo->apply(state, osg::FrameBufferObject::DRAW_FRAMEBUFFER);
+
+                ext->glBlitFramebuffer(0, 0, mOpaqueDepthTex->getTextureWidth(), mOpaqueDepthTex->getTextureHeight(), 0, 0, mOpaqueDepthTex->getTextureWidth(), mOpaqueDepthTex->getTextureHeight(), GL_DEPTH_BUFFER_BIT, GL_NEAREST);
+
+                mSourceFbo->apply(state);
+            }
+
+            bin->drawImplementation(renderInfo, previous);
+        }
+    private:
+        osg::ref_ptr<osg::FrameBufferObject> mOpaqueDepthFbo;
+        osg::ref_ptr<osg::FrameBufferObject> mSourceFbo;
+        osg::ref_ptr<osg::Texture2D> mOpaqueDepthTex;
+    };
 }
 
 namespace MWRender
@@ -103,7 +138,9 @@ namespace MWRender
         , mDepthFormat(GL_DEPTH_COMPONENT24)
         , mRendering(rendering)
     {
-        if (!SceneUtil::getReverseZ())
+        bool softParticles = Settings::Manager::getBool("soft particles", "Shaders");
+
+        if (!SceneUtil::getReverseZ() && !softParticles)
             return;
 
         osg::GraphicsContext* gc = viewer->getCamera()->getGraphicsContext();
@@ -124,17 +161,22 @@ namespace MWRender
             return;
         }
 
-        if (osg::isGLExtensionSupported(contextID, "GL_ARB_depth_buffer_float"))
-            mDepthFormat = GL_DEPTH_COMPONENT32F;
-        else if (osg::isGLExtensionSupported(contextID, "GL_NV_depth_buffer_float"))
-            mDepthFormat = GL_DEPTH_COMPONENT32F_NV;
-        else
+        if (SceneUtil::getReverseZ())
         {
-            // TODO: Once we have post-processing implemented we want to skip this return and continue with setup.
-            // Rendering to a FBO to fullscreen geometry has overhead (especially when MSAA is enabled) and there are no
-            // benefits if no floating point depth formats are supported.
-            Log(Debug::Warning) << errPreamble << "'GL_ARB_depth_buffer_float' and 'GL_NV_depth_buffer_float' unsupported.";
-            return;
+            if (osg::isGLExtensionSupported(contextID, "GL_ARB_depth_buffer_float"))
+                mDepthFormat = GL_DEPTH_COMPONENT32F;
+            else if (osg::isGLExtensionSupported(contextID, "GL_NV_depth_buffer_float"))
+                mDepthFormat = GL_DEPTH_COMPONENT32F_NV;
+            else
+            {
+                // TODO: Once we have post-processing implemented we want to skip this return and continue with setup.
+                // Rendering to a FBO to fullscreen geometry has overhead (especially when MSAA is enabled) and there are no
+                // benefits if no floating point depth formats are supported.
+                Log(Debug::Warning) << errPreamble << "'GL_ARB_depth_buffer_float' and 'GL_NV_depth_buffer_float' unsupported.";
+
+                if (!softParticles)
+                    return;
+            }
         }
 
         int width = viewer->getCamera()->getViewport()->width();
@@ -165,6 +207,12 @@ namespace MWRender
         mDepthTex->dirtyTextureObject();
         mSceneTex->dirtyTextureObject();
 
+        if (mOpaqueDepthTex)
+        {
+            mOpaqueDepthTex->setTextureSize(width, height);
+            mOpaqueDepthTex->dirtyTextureObject();
+        }
+
         int samples = Settings::Manager::getInt("antialiasing", "Video");
 
         mFbo = new osg::FrameBufferObject;
@@ -186,6 +234,9 @@ namespace MWRender
         if (const auto depthProxy = std::getenv("OPENMW_ENABLE_DEPTH_CLEAR_PROXY"))
             mFirstPersonDepthRBProxy = new osg::RenderBuffer(width, height, mDepthTex->getInternalFormat(), samples);
 
+//        if (Settings::Manager::getBool("soft particles", "Shaders"))
+//            osgUtil::RenderBin::getRenderBinPrototype("DepthSortedBin")->setDrawCallback(new OpaqueDepthCopyCallback(mOpaqueDepthTex, mMsaaFbo ? mMsaaFbo : mFbo));
+
         mViewer->getCamera()->resize(width, height);
         mHUDCamera->resize(width, height);
         mRendering.updateProjectionMatrix();
@@ -204,6 +255,12 @@ namespace MWRender
         mDepthTex->setWrap(osg::Texture::WRAP_T, osg::Texture::CLAMP_TO_EDGE);
         mDepthTex->setResizeNonPowerOfTwoHint(false);
 
+        if (Settings::Manager::getBool("soft particles", "Shaders"))
+        {
+            mOpaqueDepthTex = mDepthTex;
+            mOpaqueDepthTex->setName("opaqueTexMap");
+        }
+
         mSceneTex = new osg::Texture2D;
         mSceneTex->setTextureSize(width, height);
         mSceneTex->setSourceFormat(GL_RGB);
diff --git a/apps/openmw/mwrender/postprocessor.hpp b/apps/openmw/mwrender/postprocessor.hpp
index 0d03d4b500abf19581258ed8ab7830ae66bbe414..cc5128d8f988f3a235e79918e909e38227f24992 100644
--- a/apps/openmw/mwrender/postprocessor.hpp
+++ b/apps/openmw/mwrender/postprocessor.hpp
@@ -26,6 +26,7 @@ namespace MWRender
         auto getFirstPersonRBProxy() { return mFirstPersonDepthRBProxy; }
 
         int getDepthFormat() { return mDepthFormat; }
+        osg::ref_ptr<osg::Texture2D> getOpaqueDepthTex() { return mOpaqueDepthTex; }
 
         void resize(int width, int height);
 
@@ -42,6 +43,7 @@ namespace MWRender
 
         osg::ref_ptr<osg::Texture2D> mSceneTex;
         osg::ref_ptr<osg::Texture2D> mDepthTex;
+        osg::ref_ptr<osg::Texture2D> mOpaqueDepthTex;
 
         int mDepthFormat;
 
diff --git a/apps/openmw/mwrender/renderingmanager.cpp b/apps/openmw/mwrender/renderingmanager.cpp
index 7b8393f6908b66bb51dc9f6600e2916c1cc63f97..a12954382838d4ede0eb918d4cd5d478370554bc 100644
--- a/apps/openmw/mwrender/renderingmanager.cpp
+++ b/apps/openmw/mwrender/renderingmanager.cpp
@@ -91,6 +91,7 @@ namespace MWRender
             stateset->addUniform(new osg::Uniform("linearFac", 0.f));
             stateset->addUniform(new osg::Uniform("near", 0.f));
             stateset->addUniform(new osg::Uniform("far", 0.f));
+            stateset->addUniform(new osg::Uniform("screenRes", osg::Vec2f{}));
             if (mUsePlayerUniforms)
             {
                 stateset->addUniform(new osg::Uniform("windSpeed", 0.0f));
@@ -116,6 +117,10 @@ namespace MWRender
             if (uFar)
                 uFar->set(mFar);
 
+            auto* uScreenRes = stateset->getUniform("screenRes");
+            if (uScreenRes)
+                uScreenRes->set(mScreenRes);
+
             if (mUsePlayerUniforms)
             {
                 auto* windSpeed = stateset->getUniform("windSpeed");
@@ -148,6 +153,11 @@ namespace MWRender
             mFar = far;
         }
 
+        void setScreenRes(float width, float height)
+        {
+            mScreenRes = osg::Vec2f(width, height);
+        }
+
         void setWindSpeed(float windSpeed)
         {
             mWindSpeed = windSpeed;
@@ -167,6 +177,7 @@ namespace MWRender
         bool mUsePlayerUniforms;
         float mWindSpeed;
         osg::Vec3f mPlayerPos;
+        osg::Vec2f mScreenRes;
     };
 
     class StateUpdater : public SceneUtil::StateSetUpdater
@@ -453,6 +464,7 @@ namespace MWRender
 
         mPostProcessor = new PostProcessor(*this, viewer, mRootNode);
         resourceSystem->getSceneManager()->setDepthFormat(mPostProcessor->getDepthFormat());
+        resourceSystem->getSceneManager()->setOpaqueDepthTex(mPostProcessor->getOpaqueDepthTex());
 
         if (reverseZ && !SceneUtil::isFloatingPointDepthFormat(mPostProcessor->getDepthFormat()))
             Log(Debug::Warning) << "Floating point depth format not in use but reverse-z buffer is enabled, consider disabling it.";
@@ -1166,6 +1178,7 @@ namespace MWRender
 
         mSharedUniformStateUpdater->setNear(mNearClip);
         mSharedUniformStateUpdater->setFar(mViewDistance);
+        mSharedUniformStateUpdater->setScreenRes(mViewer->getCamera()->getViewport()->width(), mViewer->getCamera()->getViewport()->height()); 
 
         // Since our fog is not radial yet, we should take FOV in account, otherwise terrain near viewing distance may disappear.
         // Limit FOV here just for sure, otherwise viewing distance can be too high.
diff --git a/components/nifosg/nifloader.cpp b/components/nifosg/nifloader.cpp
index 838895eb47535d326d688916a38a18a7a74107ea..a745d50edaf2db5095b818ef92ab374c0b37f68e 100644
--- a/components/nifosg/nifloader.cpp
+++ b/components/nifosg/nifloader.cpp
@@ -1045,6 +1045,7 @@ namespace NifOsg
         void handleParticleSystem(const Nif::Node *nifNode, osg::Group *parentNode, SceneUtil::CompositeStateSetUpdater* composite, int animflags)
         {
             osg::ref_ptr<ParticleSystem> partsys (new ParticleSystem);
+            partsys->getOrCreateStateSet();
             partsys->setSortMode(osgParticle::ParticleSystem::SORT_BACK_TO_FRONT);
 
             const Nif::NiParticleSystemController* partctrl = nullptr;
diff --git a/components/resource/scenemanager.cpp b/components/resource/scenemanager.cpp
index 4184a77c54708b25a34e072a7607ec2a545ccb16..b6608ab6318a12b62ed485cd36b396105b597d11 100644
--- a/components/resource/scenemanager.cpp
+++ b/components/resource/scenemanager.cpp
@@ -429,6 +429,11 @@ namespace Resource
         mConvertAlphaTestToAlphaToCoverage = convert;
     }
 
+    void SceneManager::setOpaqueDepthTex(osg::ref_ptr<osg::Texture2D> texture)
+    {
+        mOpaqueDepthTex = texture;
+    }
+
     SceneManager::~SceneManager()
     {
         // this has to be defined in the .cpp file as we can't delete incomplete types
@@ -891,6 +896,7 @@ namespace Resource
         shaderVisitor->setSpecularMapPattern(mSpecularMapPattern);
         shaderVisitor->setApplyLightingToEnvMaps(mApplyLightingToEnvMaps);
         shaderVisitor->setConvertAlphaTestToAlphaToCoverage(mConvertAlphaTestToAlphaToCoverage);
+        shaderVisitor->setOpaqueDepthTex(mOpaqueDepthTex);
         return shaderVisitor;
     }
 }
diff --git a/components/resource/scenemanager.hpp b/components/resource/scenemanager.hpp
index 85e012071dfd75855c06b0372fd2b15a295826ab..58ae8fdb8b89b66ea01079e108b71f85432e4114 100644
--- a/components/resource/scenemanager.hpp
+++ b/components/resource/scenemanager.hpp
@@ -9,6 +9,7 @@
 #include <osg/ref_ptr>
 #include <osg/Node>
 #include <osg/Texture>
+#include <osg/Texture2D>
 
 #include "resourcemanager.hpp"
 
@@ -111,6 +112,8 @@ namespace Resource
         void setSupportedLightingMethods(const SceneUtil::LightManager::SupportedMethods& supported);
         bool isSupportedLightingMethod(SceneUtil::LightingMethod method) const;
 
+        void setOpaqueDepthTex(osg::ref_ptr<osg::Texture2D> texture);
+
         enum class UBOBinding
         {
             // If we add more UBO's, we should probably assign their bindings dynamically according to the current count of UBO's in the programTemplate
@@ -209,6 +212,7 @@ namespace Resource
         SceneUtil::LightManager::SupportedMethods mSupportedLightingMethods;
         bool mConvertAlphaTestToAlphaToCoverage;
         GLenum mDepthFormat;
+        osg::ref_ptr<osg::Texture2D> mOpaqueDepthTex;
 
         osg::ref_ptr<Resource::SharedStateManager> mSharedStateManager;
         mutable std::mutex mSharedStateMutex;
diff --git a/components/shader/shadervisitor.cpp b/components/shader/shadervisitor.cpp
index 9877ab18637be525f5e14a241ff285271b321d69..2c673200f79b277e51a3a22890041fc98e007544 100644
--- a/components/shader/shadervisitor.cpp
+++ b/components/shader/shadervisitor.cpp
@@ -11,6 +11,8 @@
 #include <osg/Texture>
 #include <osg/ValueObject>
 
+#include <osgParticle/ParticleSystem>
+
 #include <osgUtil/TangentSpaceGenerator>
 
 #include <components/debug/debuglog.hpp>
@@ -19,6 +21,7 @@
 #include <components/vfs/manager.hpp>
 #include <components/sceneutil/riggeometry.hpp>
 #include <components/sceneutil/morphgeometry.hpp>
+#include <components/sceneutil/util.hpp>
 
 #include "removedalphafunc.hpp"
 #include "shadermanager.hpp"
@@ -554,6 +557,20 @@ namespace Shader
             updateAddedState(*writableUserData, addedState);
         }
 
+        if (auto partsys = dynamic_cast<osgParticle::ParticleSystem*>(&node))
+        {
+            defineMap["softParticles"] = "1";
+
+            auto depth = SceneUtil::createDepth();
+            depth->setWriteMask(false);
+            writableStateSet->setAttributeAndModes(depth, osg::StateAttribute::ON|osg::StateAttribute::OVERRIDE);
+            writableStateSet->addUniform(new osg::Uniform("particleSize", partsys->getDefaultParticleTemplate().getSizeRange().maximum));
+            writableStateSet->addUniform(new osg::Uniform("opaqueDepthTex", 2));
+            writableStateSet->setTextureAttributeAndModes(2, mOpaqueDepthTex, osg::StateAttribute::ON);
+        }
+        else
+            defineMap["softParticles"] = "0";
+
         std::string shaderPrefix;
         if (!node.getUserValue("shaderPrefix", shaderPrefix))
             shaderPrefix = mDefaultShaderPrefix;
@@ -769,6 +786,11 @@ namespace Shader
         mConvertAlphaTestToAlphaToCoverage = convert;
     }
 
+    void ShaderVisitor::setOpaqueDepthTex(osg::ref_ptr<osg::Texture2D> texture)
+    {
+        mOpaqueDepthTex = texture;
+    }
+
     ReinstateRemovedStateVisitor::ReinstateRemovedStateVisitor(bool allowedToModifyStateSets)
         : osg::NodeVisitor(TRAVERSE_ALL_CHILDREN)
         , mAllowedToModifyStateSets(allowedToModifyStateSets)
diff --git a/components/shader/shadervisitor.hpp b/components/shader/shadervisitor.hpp
index 5f9739ea90380cbdec6d9cf03c7ee6304ed9a40b..d80e697fd8db069f64c42cd6ba65db31b151788d 100644
--- a/components/shader/shadervisitor.hpp
+++ b/components/shader/shadervisitor.hpp
@@ -3,6 +3,7 @@
 
 #include <osg/NodeVisitor>
 #include <osg/Program>
+#include <osg/Texture2D>
 
 namespace Resource
 {
@@ -45,6 +46,8 @@ namespace Shader
 
         void setConvertAlphaTestToAlphaToCoverage(bool convert);
 
+        void setOpaqueDepthTex(osg::ref_ptr<osg::Texture2D> texture);
+
         void apply(osg::Node& node) override;
 
         void apply(osg::Drawable& drawable) override;
@@ -110,6 +113,7 @@ namespace Shader
         bool adjustGeometry(osg::Geometry& sourceGeometry, const ShaderRequirements& reqs);
 
         osg::ref_ptr<const osg::Program> mProgramTemplate;
+        osg::ref_ptr<osg::Texture2D> mOpaqueDepthTex;
     };
 
     class ReinstateRemovedStateVisitor : public osg::NodeVisitor
diff --git a/docs/source/reference/modding/settings/shaders.rst b/docs/source/reference/modding/settings/shaders.rst
index 03b7805de6aa2a20335a8c38e8be1f44aaf20fe2..b9d8cfe1b97a23b556b12dc9a443a5ea381c4f6f 100644
--- a/docs/source/reference/modding/settings/shaders.rst
+++ b/docs/source/reference/modding/settings/shaders.rst
@@ -241,7 +241,7 @@ lighting` is on.
 This setting has no effect if :ref:`lighting method` is 'legacy'.
 
 minimum interior brightness
-------------------------
+---------------------------
 
 :Type:		float
 :Range:		0.0-1.0
@@ -260,7 +260,7 @@ aforementioned changes in visuals.
 This setting has no effect if :ref:`lighting method` is 'legacy'.
 
 antialias alpha test
----------------------------------------
+--------------------
 
 :Type:		boolean
 :Range:		True/False
@@ -269,3 +269,16 @@ antialias alpha test
 Convert the alpha test (cutout/punchthrough alpha) to alpha-to-coverage when :ref:`antialiasing` is on.
 This allows MSAA to work with alpha-tested meshes, producing better-looking edges without pixelation.
 When MSAA is off, this setting will have no visible effect, but might have a performance cost.
+
+soft particles
+--------------
+
+:Type:		boolean
+:Range:		True/False
+:Default:	False
+
+Enables soft particles for particle effects. This technique softens the
+intersection between individual particles and other opaque geometry by blending
+between them. Note, this relies on overriding specific properties of particle
+systems that potentially differ from the source content, this setting may change
+the look of some particle systems.
diff --git a/files/settings-default.cfg b/files/settings-default.cfg
index 27a9544ea670ca3bc1e7210830e2c7ff4487cf79..90e9323db74fc0fe7b1d436e09855679cad2d063 100644
--- a/files/settings-default.cfg
+++ b/files/settings-default.cfg
@@ -494,6 +494,9 @@ minimum interior brightness = 0.08
 # When MSAA is off, this setting will have no visible effect, but might have a performance cost.
 antialias alpha test = false
 
+# Soften intersection of blended particle systems with opaque geometry
+soft particles = false
+
 [Input]
 
 # Capture control of the cursor prevent movement outside the window.
diff --git a/files/shaders/CMakeLists.txt b/files/shaders/CMakeLists.txt
index d86719f31865e63c91fd208b4e452367605243e3..6e19263a38cd1bf78bfed14748c60bc74fd5e3a2 100644
--- a/files/shaders/CMakeLists.txt
+++ b/files/shaders/CMakeLists.txt
@@ -39,6 +39,7 @@ set(SHADER_FILES
     sky_vertex.glsl
     sky_fragment.glsl
     skypasses.glsl
+    softparticles.glsl
 )
 
 copy_all_resource_files(${CMAKE_CURRENT_SOURCE_DIR} ${OPENMW_SHADERS_ROOT} ${DDIRRELATIVE} "${SHADER_FILES}")
diff --git a/files/shaders/objects_fragment.glsl b/files/shaders/objects_fragment.glsl
index 6f6cede4e42c3f73092877ad97b16dd18202072f..d750a4dd1faeab9547bb7f3ea150026ec60b8e98 100644
--- a/files/shaders/objects_fragment.glsl
+++ b/files/shaders/objects_fragment.glsl
@@ -80,6 +80,10 @@ varying vec3 passNormal;
 #include "parallax.glsl"
 #include "alpha.glsl"
 
+#if @softParticles
+#include "softparticles.glsl"
+#endif
+
 void main()
 {
 #if @diffuseMap
@@ -220,6 +224,10 @@ void main()
 #endif
     gl_FragData[0].xyz = mix(gl_FragData[0].xyz, gl_Fog.color.xyz, fogValue);
 
+#if @softParticles
+    gl_FragData[0].a *= calcSoftParticleFade();
+#endif
+
 #if defined(FORCE_OPAQUE) && FORCE_OPAQUE
     // having testing & blending isn't enough - we need to write an opaque pixel to be opaque
     gl_FragData[0].a = 1.0;
diff --git a/files/shaders/softparticles.glsl b/files/shaders/softparticles.glsl
new file mode 100644
index 0000000000000000000000000000000000000000..fa8b4de4c118c7d0c14f5d92a7352f022d9306bd
--- /dev/null
+++ b/files/shaders/softparticles.glsl
@@ -0,0 +1,32 @@
+uniform float near;
+uniform float far;
+uniform highp sampler2D opaqueDepthTex;
+uniform vec2 screenRes;
+uniform float particleSize;
+
+float viewDepth(float depth)
+{
+#if @reverseZ
+    depth = 1.0 - depth;
+#endif
+    return (near * far) / ((far - near) * depth - far);
+}
+
+float calcSoftParticleFade()
+{
+    const float falloffMultiplier = 0.33;
+    const float contrast = 1.30;
+
+    vec2 screenCoords = gl_FragCoord.xy / screenRes;
+    float sceneDepth = viewDepth(texture2D(opaqueDepthTex, screenCoords).x);
+    float particleDepth = viewDepth(gl_FragCoord.z);
+    float falloff = particleSize * falloffMultiplier;
+    float delta = particleDepth - sceneDepth;
+
+    if (delta < 0.0)
+        discard;
+
+    const float shift = 0.845;
+
+    return shift * pow(clamp(delta/falloff, 0.0, 1.0), contrast);
+}
diff --git a/files/ui/advancedpage.ui b/files/ui/advancedpage.ui
index 7964399319b899f2b170f9abea296ccd4a3bffbe..0e80f027007f14bc3fd5e99c7cc520b1f2935934 100644
--- a/files/ui/advancedpage.ui
+++ b/files/ui/advancedpage.ui
@@ -444,6 +444,16 @@
                 </property>
                </widget>
               </item>
+              <item row="3" column="0">
+               <widget class="QCheckBox" name="softParticlesCheckBox">
+                <property name="toolTip">
+                 <string>&lt;html&gt;&lt;head/&gt;&lt;body&gt;&lt;p&gt;Enables soft particles for particle effects. This technique softens the intersection between individual particles and other opaque geometry by blending between them.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</string>
+                </property>
+                <property name="text">
+                 <string>Soft Particles</string>
+                </property>
+               </widget>
+              </item>
              </layout>
             </widget>
            </item>
